"use strict";(self.webpackChunksea_ql_blog=self.webpackChunksea_ql_blog||[]).push([[3201],{3905:(e,t,a)=>{a.d(t,{Zo:()=>u,kt:()=>d});var r=a(7294);function n(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function o(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,r)}return a}function i(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?o(Object(a),!0).forEach((function(t){n(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):o(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function s(e,t){if(null==e)return{};var a,r,n=function(e,t){if(null==e)return{};var a,r,n={},o=Object.keys(e);for(r=0;r<o.length;r++)a=o[r],t.indexOf(a)>=0||(n[a]=e[a]);return n}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(r=0;r<o.length;r++)a=o[r],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(n[a]=e[a])}return n}var l=r.createContext({}),m=function(e){var t=r.useContext(l),a=t;return e&&(a="function"==typeof e?e(t):i(i({},t),e)),a},u=function(e){var t=m(e.components);return r.createElement(l.Provider,{value:t},e.children)},c={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},p=r.forwardRef((function(e,t){var a=e.components,n=e.mdxType,o=e.originalType,l=e.parentName,u=s(e,["components","mdxType","originalType","parentName"]),p=m(a),d=n,h=p["".concat(l,".").concat(d)]||p[d]||c[d]||o;return a?r.createElement(h,i(i({ref:t},u),{},{components:a})):r.createElement(h,i({ref:t},u))}));function d(e,t){var a=arguments,n=t&&t.mdxType;if("string"==typeof e||n){var o=a.length,i=new Array(o);i[0]=p;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:n,i[1]=s;for(var m=2;m<o;m++)i[m]=a[m];return r.createElement.apply(null,i)}return r.createElement.apply(null,a)}p.displayName="MDXCreateElement"},4263:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>l,contentTitle:()=>i,default:()=>c,frontMatter:()=>o,metadata:()=>s,toc:()=>m});var r=a(7462),n=(a(7294),a(3905));const o={slug:"2023-09-06-whats-new-in-sea-streamer-0.3",title:"What's new in SeaStreamer 0.3",author:"Chris Tsang",author_title:"SeaQL Team",author_url:"https://github.com/tyt2y3",author_image_url:"https://avatars.githubusercontent.com/u/1782664?v=4",tags:["news"]},i=void 0,s={permalink:"/blog/2023-09-06-whats-new-in-sea-streamer-0.3",editUrl:"https://github.com/SeaQL/seaql.github.io/edit/master/Blog/blog/2023-09-06-whats-new-in-sea-streamer-0.3.md",source:"@site/blog/2023-09-06-whats-new-in-sea-streamer-0.3.md",title:"What's new in SeaStreamer 0.3",description:"\ud83c\udf89 We are pleased to release SeaStreamer 0.3.x!",date:"2023-09-06T00:00:00.000Z",formattedDate:"September 6, 2023",tags:[{label:"news",permalink:"/blog/tags/news"}],readingTime:4.24,hasTruncateMarker:!1,authors:[{name:"Chris Tsang",title:"SeaQL Team",url:"https://github.com/tyt2y3",imageURL:"https://avatars.githubusercontent.com/u/1782664?v=4"}],frontMatter:{slug:"2023-09-06-whats-new-in-sea-streamer-0.3",title:"What's new in SeaStreamer 0.3",author:"Chris Tsang",author_title:"SeaQL Team",author_url:"https://github.com/tyt2y3",author_image_url:"https://avatars.githubusercontent.com/u/1782664?v=4",tags:["news"]},nextItem:{title:"Announcing SeaORM 0.12 \ud83d\udc1a",permalink:"/blog/2023-08-12-announcing-seaorm-0.12"}},l={authorsImageUrls:[void 0]},m=[{value:"File Backend",id:"file-backend",level:2},{value:"Encode free",id:"encode-free",level:3},{value:"Efficient seek",id:"efficient-seek",level:3},{value:"Streaming friendly",id:"streaming-friendly",level:3},{value:"Summary",id:"summary",level:4},{value:"Redis Backend",id:"redis-backend",level:2},{value:"Benchmark",id:"benchmark",level:2},{value:"Producer",id:"producer",level:4},{value:"Consumer",id:"consumer",level:4},{value:"Community",id:"community",level:2}],u={toc:m};function c(e){let{components:t,...a}=e;return(0,n.kt)("wrapper",(0,r.Z)({},u,a,{components:t,mdxType:"MDXLayout"}),(0,n.kt)("a",{href:"https://www.sea-ql.org/SeaStreamer/"},(0,n.kt)("img",{src:"https://www.sea-ql.org/SeaStreamer/img/SeaStreamer%20banner.png"})),(0,n.kt)("p",null,"\ud83c\udf89 We are pleased to release SeaStreamer ",(0,n.kt)("a",{parentName:"p",href:"https://github.com/SeaQL/sea-streamer/releases/0.3.0"},(0,n.kt)("inlineCode",{parentName:"a"},"0.3.x")),"!"),(0,n.kt)("h2",{id:"file-backend"},"File Backend"),(0,n.kt)("p",null,"A major addition in SeaStreamer ",(0,n.kt)("inlineCode",{parentName:"p"},"0.3")," is the file backend. It implements the same high-level MPMC API, so now we can stream to and from files. There are different usecases, for example, it can be used to dump data from Redis / Kafka and process them locally, or as an intermediate file format for storage or transport."),(0,n.kt)("p",null,"The SeaStreamer File format, ",(0,n.kt)("inlineCode",{parentName:"p"},".ss")," is pretty simple. It's very much like ",(0,n.kt)("inlineCode",{parentName:"p"},".ndjson"),", but binary. The file format is designed with the following goals:"),(0,n.kt)("ol",null,(0,n.kt)("li",{parentName:"ol"},"Support binary data without encoding overhead"),(0,n.kt)("li",{parentName:"ol"},"Efficient to rewind / seek through a large dump"),(0,n.kt)("li",{parentName:"ol"},"Streaming friendly. File can be truncated without losing integrity")),(0,n.kt)("p",null,"Let me explain in details."),(0,n.kt)("p",null,"First of all, SeaStreamer File is a container format. It only concerns the message stream and framing, not the payload. It's designed to be pair with a binary message format like Protobuf or BSON."),(0,n.kt)("h3",{id:"encode-free"},"Encode free"),(0,n.kt)("p",null,"JSON and CSV are great plain text file formats, but they are not binary friendly. Usually, to encode binary data, one would use ",(0,n.kt)("inlineCode",{parentName:"p"},"base64"),". It therefore imposes an expensive encoding / decoding overhead. In a binary protocol, ",(0,n.kt)("em",{parentName:"p"},"delimiters")," are frequently used to signal message boundaries. As a consequence, byte stuffing is needed to escape the bytes."),(0,n.kt)("p",null,"In SeaStreamer, we want to avoid the encoding overhead entirely. The payload should be written to disk verbatim. So the file format revolves around constructing message frames and placing checksums to ensure data is interpreted correctly."),(0,n.kt)("h3",{id:"efficient-seek"},"Efficient seek"),(0,n.kt)("p",null,"Delimiter based protocol has an advantage: the byte stream can be randomly sought, and we should have no trouble reading the next message."),(0,n.kt)("p",null,"Since SeaStreamer does not use delimiters, we can't easily align to message frames after a random seek. We solve this problem by placing beacons in a regular interval at fixed locations throughout the file. E.g. say the ",(0,n.kt)("inlineCode",{parentName:"p"},"beacon interval")," is ",(0,n.kt)("inlineCode",{parentName:"p"},"1024"),", there will be a beacon at 1024th, 2048th byte and so on. So everytime we want to seek to a random location, we'd seek to the closest N * 1024 byte and read from there."),(0,n.kt)("p",null,"These beacons also double as indices: they contain summaries of the individual streams. So given a particular stream key and sequence number (or timestamp) to search for, SeaStreamer can quickly locate the message ",(0,n.kt)("em",{parentName:"p"},"just by")," reading the beacons. It doesn't matter if the stream's messages are sparse!"),(0,n.kt)("h3",{id:"streaming-friendly"},"Streaming friendly"),(0,n.kt)("p",null,"It should be safe to truncate files. It should be relatively easy to stitch together several files without expensive re-encoding. We should know if the data is corrupted."),(0,n.kt)("p",null,"SeaStreamer achieves this by computing checksums for every message, and also the running checksum of the checksums for each stream. It's not enforced right now, but in theory we can detect if any messages are missing from a stream."),(0,n.kt)("h4",{id:"summary"},"Summary"),(0,n.kt)("p",null,"This file format is also easy to implement in different languages, as we just made an (experimental) ",(0,n.kt)("a",{parentName:"p",href:"https://github.com/SeaQL/sea-streamer/tree/main/sea-streamer-file/sea-streamer-file-reader"},"reader in Typescript"),"."),(0,n.kt)("p",null,"That's it! If you are interested, you can go and take a look at the ",(0,n.kt)("a",{parentName:"p",href:"https://docs.rs/sea-streamer-file/latest/sea_streamer_file/format/index.html"},"format description"),"."),(0,n.kt)("h2",{id:"redis-backend"},"Redis Backend"),(0,n.kt)("p",null,"Redis Streams are underrated! It has a high throughput and concurrency, and is best suited for non-persistent stream processing near or on the same host as the application."),(0,n.kt)("p",null,"The obstacle is probably in library support. Redis Streams' API is rather low level, and there aren't many high-level libraries to help with programming. Compared to Kafka, which has versatile official programming libraries."),(0,n.kt)("p",null,"The pitfall is, it's not easy to maximize concurrency with the raw Redis API. To start, you'd need to pipeline ",(0,n.kt)("inlineCode",{parentName:"p"},"XADD")," commands. You'd also need to time and batch ",(0,n.kt)("inlineCode",{parentName:"p"},"XACK"),"s so that it does not block reads and computation. And of course you should separate the reads and writes on different threads."),(0,n.kt)("p",null,"SeaStreamer breaks these obstacles for you and offers a Kafka-like API experience!"),(0,n.kt)("h2",{id:"benchmark"},"Benchmark"),(0,n.kt)("p",null,"In ",(0,n.kt)("inlineCode",{parentName:"p"},"0.3"),", we have done some optimizations to improve the throughput of the Redis and File backend. We set our initial benchmark at 100k messages per second, which hopefully we can further improve over time."),(0,n.kt)("p",null,"Our ",(0,n.kt)("a",{parentName:"p",href:"https://github.com/SeaQL/sea-streamer/tree/main/benchmark"},"micro benchmark")," involves a simple program producing or consuming 100k messages, where each message has a payload of 256 bytes."),(0,n.kt)("p",null,"For Redis, it's running on the same computer in Docker. On my not-very-impressive laptop with a 10th Gen Intel Core i7, the numbers are somewhat around:"),(0,n.kt)("h4",{id:"producer"},"Producer"),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre"},"redis    0.5s\nstdio    0.5s\nfile     0.5s\n")),(0,n.kt)("h4",{id:"consumer"},"Consumer"),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre"},"redis    1.0s\nstdio    1.0s\nfile     1.1s\n")),(0,n.kt)("p",null,"It practically means that we are comfortably in the realm of ",(0,n.kt)("em",{parentName:"p"},"producing")," 100k messages per second, but are just about able to ",(0,n.kt)("em",{parentName:"p"},"consume")," 100k messages in 1 second. Suggestions to performance improvements are welcomed!"),(0,n.kt)("h2",{id:"community"},"Community"),(0,n.kt)("p",null,"SeaQL.org is an independent open-source organization run by passionate \ufe0fdevelopers. If you like our projects, please star \u2b50 and share our repositories. If you feel generous, a small donation via ",(0,n.kt)("a",{parentName:"p",href:"https://github.com/sponsors/SeaQL"},"GitHub Sponsor")," will be greatly appreciated, and goes a long way towards sustaining the organization \ud83d\udea2."),(0,n.kt)("p",null,"SeaStreamer is a community driven project. We welcome you to participate, contribute and together build for Rust's future \ud83e\udd80."))}c.isMDXComponent=!0}}]);